name: Build Nightingale (linux/armv7)

on:
  push:
    branches:
      - '**'
  workflow_dispatch: {}

jobs:
  build-armv7:
    runs-on: ubuntu-latest
    env:
      GO111MODULE: on

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine go version from go.mod (if exists)
        id: gov
        run: |
          if [ -f go.mod ]; then
            gv=$(grep '^go ' go.mod | awk '{print $2}' || true)
            if [ -n "$gv" ]; then
              echo "go_version=$gv" >> $GITHUB_OUTPUT
            else
              echo "go_version=1.21" >> $GITHUB_OUTPUT
            fi
          else
            echo "go_version=1.21" >> $GITHUB_OUTPUT
          fi

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ steps.gov.outputs.go_version }}

      # ===== 插入点：在这里开始补丁步骤（必须在 go 已安装之后） =====
      - name: Patch ibex for armv7 (robust - fixed rsync logic)
        id: patch_ibex
        run: |
          set -euo pipefail

          TMP=/tmp/ibex
          TARGET_ROOT="$GITHUB_WORKSPACE/third_party/ibex"

          rm -rf "$TMP"
          git clone --depth 1 https://github.com/flashcatcloud/ibex.git "$TMP" || (echo "clone failed"; exit 1)
          cd "$TMP"
          # optional: checkout tag/commit
          # git checkout v1.3.5 || true

          # 1) 在克隆目录里查找 go.mod（优先）
          MODFILE=$(find "$TMP" -maxdepth 6 -name go.mod -print -quit || true)
          if [ -n "$MODFILE" ]; then
            echo "Found go.mod in clone at: $MODFILE"
            MODROOT=$(dirname "$MODFILE")
            echo "Module root in clone: $MODROOT"
            # 将模块根复制到工作区 third_party/ibex（覆盖）
            rm -rf "$TARGET_ROOT"
            mkdir -p "$(dirname "$TARGET_ROOT")"
            rsync -a --exclude '.git' "$MODROOT"/ "$TARGET_ROOT"/ || { echo "rsync failed from MODROOT"; exit 1; }
          else
            # 没有 go.mod，尝试使用 src/ 作为模块根
            if [ -d "$TMP/src" ]; then
              echo "No go.mod found; using $TMP/src as module root"
              rm -rf "$TARGET_ROOT"
              mkdir -p "$TARGET_ROOT"
              rsync -a --exclude '.git' "$TMP/src"/ "$TARGET_ROOT"/ || { echo "rsync failed from src"; exit 1; }
              # 初始化最小 go.mod（module 名必须与 import path 一致）
              printf '%s\n' "module github.com/flashcatcloud/ibex" "" "go 1.21" > "$TARGET_ROOT/go.mod"
              (cd "$TARGET_ROOT" && go mod tidy) || true
            else
              # 兜底：把整个仓库复制过去（不推荐，但保证不会中断 CI）
              echo "No go.mod and no src/ dir; copying full repo to target"
              rm -rf "$TARGET_ROOT"
              mkdir -p "$TARGET_ROOT"
              rsync -a --exclude '.git' "$TMP"/ "$TARGET_ROOT"/ || { echo "rsync failed from tmp repo"; exit 1; }
            fi
          fi

          # 2) 在复制后的目标里应用自动补丁（仅在 TARGET_ROOT 下操作）
          ROOT="$TARGET_ROOT"
          echo "Applying code transformations under $ROOT (best-effort)"
          # 把 IDINITIAL 改为显式 int64（或 uint64，根据前面决定）
          find "$ROOT" -type f -name "*.go" -exec perl -0777 -pe \
            "s/const\s+IDINITIAL\s*=\s*4294967296/const IDINITIAL int64 = 4294967296/gms" -i {} \; || true

          # 尽力把常见函数参数/字段从 int -> int64（保守替换）
          find "$ROOT" -type f -name "*.go" -print0 | xargs -0 -n1 perl -0777 -i -pe '
            s{(\([^\)]*?\b)(\w+\s+)int\b}{$1$2int64}gms;
            s{(\bID\b\s+)int\b}{$1int64}gms;
            s{(\bId\b\s+)int\b}{$1int64}gms;
            s{(\bid\b\s+)int\b}{$1int64}gms;
            s{(\bvar\s+\w+\s+)int\b}{$1int64}gms;
            ' || true

          # 把直接使用 IDINITIAL 的调用包装为 int64(IDINITIAL)
          find "$ROOT" -type f -name "*.go" -exec perl -0777 -pe 's/\bIDINITIAL\b/int64(IDINITIAL)/gms' -i {} \; || true

          # 3) 确保 target 下存在 go.mod（如果没有，保守初始化）
          if [ ! -f "$ROOT/go.mod" ]; then
            echo "Initializing minimal go.mod at $ROOT"
            printf '%s\n' "module github.com/flashcatcloud/ibex" "" "go 1.21" > "

      # ===== 补丁步骤结束 =====

      - name: Install cross compile toolchain (for CGO or linking if needed)
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends build-essential gcc-arm-linux-gnueabihf

      - name: Prepare dist directory
        run: mkdir -p dist

      - name: Detect commands under ./cmd and build for linux/arm (armv7)
        run: |
          set -euo pipefail
          export GOOS=linux
          export GOARCH=arm
          export GOARM=7
          export CGO_ENABLED=0

          if [ -d "./cmd" ]; then
            for d in ./cmd/*; do
              if [ -d "$d" ]; then
                name=$(basename "$d")
                echo "Building $name ..."
                go build -v -o "dist/${name}-linux-armv7" "./cmd/${name}" || { echo "build ${name} failed"; exit 1; }
                file "dist/${name}-linux-armv7"
              fi
            done
          else
            go build -v -o "dist/n9e-linux-armv7" ./... || { echo "fallback build failed"; exit 1; }
            file "dist/n9e-linux-armv7"
          fi

      - name: List dist
        run: ls -la dist || true

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: nightingale-armv7
          path: dist/**
